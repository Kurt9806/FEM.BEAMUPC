# -*- coding: utf-8 -*-
"""Buckling Micropolar Beam

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1hWtPrb70NWTHcHVM_gA6JU8CB8Vha_ey
"""

import numpy as np
import math
from scipy.linalg import eigh

"""# Calculation of Mesh 1D
Code that calcultae the mesh of the system
"""

def NLMSH1D(IELEM,IPDF,DX,X0=0):

  NOD = np.zeros((IELEM,IPDF))
  for i in range(IPDF):
    NOD[1,i] = i
  for n in range(1,IELEM):
    for i in range(IPDF):
      NOD[n,i]=NOD[n-1,i]+IPDF-1
  
  # Generate the mesh of a 1D element

  GLX=[X0]
  for i in range(IELEM):
    for j in range(1,IPDF):
      GLX.append(GLX[j-1]+DX[i]/(IPDF-1))
  
  return NOD, GLX

"""# Shape functions
Calculate the Lagrangian Shape functions
"""

def SHAPE1D(H,NPE,XI):
  """Calculate the Lagrangian Shape functions in one dimension by a given length of 
  element, number of points and point value. Returns an array of values of the 
  shape function and its derivative.

  Args:
    H (float): The length of the element
    NPE (int): Number of points in each element
    XI (array): Values of quadrature points calculated
  
  Returns:
    Arrays
  """

# Calculate the Lagrangian shape functions by a given length H.
  P=NPE-1
  XF=[]
  XDF=[]

  XNODE = [-1 + 2/P*(i) for i in range(NPE)]

  for i in range(NPE):
    r3=0
    s1=1
    r1=1
    for n in range(NPE):
      if n != i:
        s1 = s1 * (XI-XNODE[n])
        r1 = r1 * (XNODE[i]-XNODE[n])
    XF.append(s1/r1)

    for m in range(NPE):
      s3 = 1
      for n in range(NPE):
        if m != i:
          if (m !=n) & (n != 1):
            s3 = s3* (XI-XNODE[n])
            g3 = s3
        else:
          g3 = 0
      
      if P == 1:
        r3 = 1
      else:
        r3 = r3 + g3
    XDF.append(r3 / r1) 

  SF = XF
  DSF = np.array(XDF)
  GJ = H*0.5
  GDSF = DSF / GJ

  return (SF, GDSF, GJ)

"""# Gauss Points
Calculation of Gauss Points using a User-defined function
"""

print(np.polynomial.legendre.leggauss(3))

"""# Calculation of Local matrices
The main code, we use a combination with Maple.
"""

def NLCOEFF(IPDF,H,E,A,I2,ue,ke,bet2,bet3,NDF=4):
  """Calculate the local matrices of lineal and geometrical stiffness.

  Args:
    IPDF (int): Number of points in an element
    H (float): length of the element
    E (float): Elasticity modulus
    A (float): Area of cross section
    I2 (float): Inercia modulus in direction 2
    ue (float): Micropolar parameter u
    ke (float): Micropolar parameter k
    bet2 (float): Micropolar parameter beta
    bet3 (float): Micropolar parameter gamma
    NDF (int, optional): Number of degrees of freedom, micropolar = 4

  Returns:
    arrays
  """ 

  GAUSPT, GAUSWT = np.polynomial.legendre.leggauss(IPDF)

  XI = GAUSPT
  SFA, GDSFA, GJ = SHAPE1D(H,IPDF,XI)
  CNSTA = GJ * GAUSWT

  ELK = np.zeros((IPDF*NDF,IPDF*NDF))
  ELKG = np.zeros((IPDF*NDF,IPDF*NDF))

  ELKk = np.zeros((NDF,NDF,IPDF,IPDF))
  ELKkg = np.zeros((NDF,NDF,IPDF,IPDF))

  A0X = -1

  # Lineal matrix ELK
  for LI in range(IPDF):
    SF = SFA[LI][:]; GDSF = GDSFA[LI][:]; CNST = CNSTA[LI]
    for II in range(IPDF):
      for JJ in range(IPDF):
        # Coefficient ELK11
        t0 = E * A * GDSF[JJ] * GDSF[II]
        ELKk[0][0][II][JJ]=ELKk[0][0][II][JJ]+t0*CNST
        # Coefficient ELK12
        t0 = 0.0e0
        ELKk[0][1][II][JJ]=ELKk[0][1][II][JJ]+t0*CNST
        # Coefficient ELK13
        t0 = 0.0e0
        ELKk[0][2][II][JJ]=ELKk[0][2][II][JJ]+t0*CNST
        # Coefficient ELK14
        t0 = 0.0e0
        ELKk[0][3][II][JJ]=ELKk[0][3][II][JJ]+t0*CNST
        # Coefficient ELK21
        t0 = 0.0e0
        ELKk[1][0][II][JJ]=ELKk[1][0][II][JJ]+t0*CNST
        # Coefficient ELK22
        t0 = (A * GDSF[JJ] * (0.5000000000e0 * ke + ue) + 
              0.5000000000e0 * A * GDSF[JJ] * ke) * GDSF[II] 
        ELKk[1][1][II][JJ]=ELKk[1][1][II][JJ]+t0*CNST
        # Coefficient ELK23
        t0 = (A * SF[JJ] * (0.5000000000e0 * ke + ue) - 
              0.5000000000e0 * A * SF[JJ] * ke) * GDSF[II] 
        ELKk[1][2][II][JJ]=ELKk[1][2][II][JJ]+t0*CNST
        # Coefficient ELK24
        t0 = -0.1e1 * A * SF[JJ] * ke * GDSF[II]
        ELKk[1][3][II][JJ]=ELKk[1][3][II][JJ]+t0*CNST
        # Coefficient ELK31
        t0 = 0.0e0
        ELKk[2][0][II][JJ]=ELKk[2][0][II][JJ]+t0*CNST
        # Coefficient ELK32
        t0 = (-0.5000000000e0 * A * GDSF[JJ] * ke + A * GDSF[JJ] * 
              (0.5000000000e0 * ke + ue)) * SF[II] 
        ELKk[2][1][II][JJ]=ELKk[2][1][II][JJ]+t0*CNST
        # Coefficient ELK33
        t0 = (0.5000000000e0 * A * SF[JJ] * ke + A * SF[JJ] * 
              (0.5000000000e0 * ke + ue)) * SF[II] + E * I2 * GDSF[JJ] * GDSF[II] 
        ELKk[2][2][II][JJ]=ELKk[2][2][II][JJ]+t0*CNST
        # Coefficient ELK34
        t0 = A * SF[JJ] * ke * SF[II]
        ELKk[2][3][II][JJ]=ELKk[2][3][II][JJ]+t0*CNST
        # Coefficient ELK41
        t0 = 0.0e0
        ELKk[3][0][II][JJ]=ELKk[3][0][II][JJ]+t0*CNST
        # Coefficient ELK42
        t0 = -0.1e1 * A * GDSF[JJ] * ke * SF[II]
        ELKk[3][1][II][JJ]=ELKk[3][1][II][JJ]+t0*CNST
        # Coefficient ELK43
        t0 = A * SF[JJ] * ke * SF[II]
        ELKk[3][2][II][JJ]=ELKk[3][2][II][JJ]+t0*CNST
        # Coefficient ELK44
        t0 = 0.2e1 * A * SF[JJ] * ke * SF[II] + (A * GDSF[JJ] * (0.5000000000e0 * bet2 + 0.5000000000e0 * bet3) + 
                                                 A * GDSF[JJ] * (-0.5000000000e0 * bet2 + 0.5000000000e0 * bet3)) * GDSF[II] 
        ELKk[3][3][II][JJ]=ELKk[3][3][II][JJ]+t0*CNST

        # Calculation of Geomterical Matrix Kg

        # Coefficient ELK11
        t0 = 0.0e0 
        ELKkg[0][0][II][JJ]=ELKk[0][0][II][JJ]+t0*CNST
        # Coefficient ELK12
        t0 = 0.0e0 
        ELKkg[0][1][II][JJ]=ELKk[0][1][II][JJ]+t0*CNST
        # Coefficient ELK13
        t0 = 0.0e0 
        ELKkg[0][2][II][JJ]=ELKk[0][2][II][JJ]+t0*CNST
        # Coefficient ELK14
        t0 = 0.0e0 
        ELKkg[0][3][II][JJ]=ELKk[0][3][II][JJ]+t0*CNST
        # Coefficient ELK21
        t0 = 0.0e0 
        ELKkg[1][0][II][JJ]=ELKk[1][0][II][JJ]+t0*CNST
        # Coefficient ELK22
        t0 = - A0X * GDSF[JJ] * GDSF[II] 
        ELKkg[1][1][II][JJ]=ELKk[1][1][II][JJ]+t0*CNST
        # Coefficient ELK23
        t0 = 0.0e0 
        ELKkg[1][2][II][JJ]=ELKk[1][2][II][JJ]+t0*CNST
        # Coefficient ELK24
        t0 = 0.0e0 
        ELKkg[1][3][II][JJ]=ELKk[1][3][II][JJ]+t0*CNST
        # Coefficient ELK31
        t0 = 0.0e0 
        ELKkg[2][0][II][JJ]=ELKk[2][0][II][JJ]+t0*CNST
        # Coefficient ELK32
        t0 = 0.0e0 
        ELKkg[2][1][II][JJ]=ELKk[2][1][II][JJ]+t0*CNST
        # Coefficient ELK33
        t0 = 0.0e0 
        ELKkg[2][2][II][JJ]=ELKk[2][2][II][JJ]+t0*CNST
        # Coefficient ELK34
        t0 = 0.0e0 
        ELKkg[2][3][II][JJ]=ELKk[2][3][II][JJ]+t0*CNST
        # Coefficient ELK41
        t0 = 0.0e0 
        ELKkg[3][0][II][JJ]=ELKk[3][0][II][JJ]+t0*CNST
        # Coefficient ELK42
        t0 = 0.0e0 
        ELKkg[3][1][II][JJ]=ELKk[3][1][II][JJ]+t0*CNST
        # Coefficient ELK43
        t0 = 0.0e0 
        ELKkg[3][2][II][JJ]=ELKk[3][2][II][JJ]+t0*CNST
        # Coefficient ELK44
        t0 = 0.0e0 
        ELKkg[3][3][II][JJ]=ELKk[3][3][II][JJ]+t0*CNST

  # Matrix Rearrenge
  II = 0
  for i in range(IPDF):
    JJ= 0
    for j in range(IPDF):
      for I in range(NDF):
        for J in range(NDF):
          ELK[II+i-1][JJ+j-1] = ELKk[I][J][i][j]
          ELKG[II+i-1][JJ+j-1] = ELKkg[I][J][i][j]
      JJ = j*NDF
    II = i*NDF

  return (ELK, ELKG)

"""# Assembly of global matrices
Assemble the matrices from local to global forms
"""

def NLASSEMBLE(NI,IPDF,GLK,GLKG,ELK,ELKG,NDF):

  # Calculation of the index of assembly
  for i in range(IPDF):
    start = (NI[i]-1) * NDF
    index = [start + j for j in range(NDF)]

  # Assembly of element stifness matrix into the system matrix
  for i in range(len(index)):
    ii = index[i]
    for j in range(len(index)):
      jj = index[i]
      GLK[ii][jj] = GLK[ii][jj] + ELK[i][j]
      GLKG[ii][jj] = GLKG[ii][jj] + ELKG[i][j]

  return GLK, GLKG

"""# Calculation of stifness and geometrical matrices
General code where the global stiffness matrix is calculated
"""

def NLSTIFF(IELEM,NEQ,NOD,GLX,IPDF,E,A,I2,ue,ke,bet2,bet3,NDF=4):
  
  GLK = np.zeros((NEQ,NEQ))
  GLKG = np.zeros((NEQ,NEQ))

  for NE in range(IELEM):
    for i in range(IPDF):
      NI = NOD[NE][i]
      ELX[i] = GLX[NI]

    # Initiate local matrices
    H = ELX[IPDF-1] - ELX[0]
    ELK, ELKG = NLCOEFF(IPDF,H,E,A,I2,ue,ke,bet2,bet3,NDF)

    # Assembly of matrices
    NI= NOD[NE][:]
    index = NLELEMENT(NI,IPDF,NDF)
    GLK, GLKG = NLASSEMBLE(NI,IPDF,GLK,GLKG,ELK,ELKG,NDF)

  return GLK, GLKG

"""# Boundary Conditions Code
Code for establishing the boundary conditions in the global matrices
"""

def NLSYMBNDRY(NSPV,ISPV,VSPV,GLK,GLKG,NDF=4):
  """Establish the boundary condition in the global matrices

  Args:
    NSPV (int): Number of primary boundary conditions
    ISPV (array): Position of primary boundary conditions
    VSPV (array): Value of primary boundary conditions
    GLK (array): Global stiffness matrix of the system
    GLKG (array): Global geometrical matrix of the system
    NDF (int,optional): Number of degrees of freedom

  Returns:
    Arrays
  """

  # Primary degrees of freedom
  if NSPV != 0:
    for NB in range(NSPV):
      FDF = (ISPV[NSPV][0]-1)*NDF+ISPV[NB][1]
      GLK[:][FDF] = 0
      GLK[FDF][:] = 0
      GLK[FDF][FDF] = 1
      GLKG[:][FDF] = 0
      GLKG[FDF][:] = 0
      GLKG[FDF][FDF] = 1

  return GLK, GLKG

"""# Main Code
This is the main code: MPBEAM 1.0
"""

# Material and section properties
b=g; Et=1/2; ET = 2*g*(1+Et)
L = map(sum, DX)
A = Bb*Hh; I2=Bb*Hh**3 / 12; I3=Bb**3*Hh/12
I1 = I2+I3

# Geometry
IPDF = P+1
NNM = IELEM*P+1
NEQ = NNM*NDF
NOD, GLX = NLMSH1D(IELEM,IPDF,DX)

# Calculation of the stifness matrices
GLK, GLKG = NLSTIFF(IELEM,NEQ,NOD,GLX,IPDF,E,A,I2,ue,ke,bet2,bet3)

# Imposition of boundary condition
GLK, GLK = NLSYMBNDRY(NSPV,ISPV,VSPV,GLK,GLKG)

# Calculation of eigenvalues and eignevectors
W, V = eigh(GLK,GLKG)